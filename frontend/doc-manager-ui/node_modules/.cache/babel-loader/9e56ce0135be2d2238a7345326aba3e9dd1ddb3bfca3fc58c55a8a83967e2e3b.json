{"ast":null,"code":"/**\r\n * @import {\r\n *   Code,\r\n *   InitialConstruct,\r\n *   Initializer,\r\n *   Resolver,\r\n *   State,\r\n *   TokenizeContext\r\n * } from 'micromark-util-types'\r\n */\n\nexport const resolver = {\n  resolveAll: createResolver()\n};\nexport const string = initializeFactory('string');\nexport const text = initializeFactory('text');\n\n/**\r\n * @param {'string' | 'text'} field\r\n *   Field.\r\n * @returns {InitialConstruct}\r\n *   Construct.\r\n */\nfunction initializeFactory(field) {\n  return {\n    resolveAll: createResolver(field === 'text' ? resolveAllLineSuffixes : undefined),\n    tokenize: initializeText\n  };\n\n  /**\r\n   * @this {TokenizeContext}\r\n   *   Context.\r\n   * @type {Initializer}\r\n   */\n  function initializeText(effects) {\n    const self = this;\n    const constructs = this.parser.constructs[field];\n    const text = effects.attempt(constructs, start, notText);\n    return start;\n\n    /** @type {State} */\n    function start(code) {\n      return atBreak(code) ? text(code) : notText(code);\n    }\n\n    /** @type {State} */\n    function notText(code) {\n      if (code === null) {\n        effects.consume(code);\n        return;\n      }\n      effects.enter(\"data\");\n      effects.consume(code);\n      return data;\n    }\n\n    /** @type {State} */\n    function data(code) {\n      if (atBreak(code)) {\n        effects.exit(\"data\");\n        return text(code);\n      }\n\n      // Data.\n      effects.consume(code);\n      return data;\n    }\n\n    /**\r\n     * @param {Code} code\r\n     *   Code.\r\n     * @returns {boolean}\r\n     *   Whether the code is a break.\r\n     */\n    function atBreak(code) {\n      if (code === null) {\n        return true;\n      }\n      const list = constructs[code];\n      let index = -1;\n      if (list) {\n        // Always populated by defaults.\n\n        while (++index < list.length) {\n          const item = list[index];\n          if (!item.previous || item.previous.call(self, self.previous)) {\n            return true;\n          }\n        }\n      }\n      return false;\n    }\n  }\n}\n\n/**\r\n * @param {Resolver | undefined} [extraResolver]\r\n *   Resolver.\r\n * @returns {Resolver}\r\n *   Resolver.\r\n */\nfunction createResolver(extraResolver) {\n  return resolveAllText;\n\n  /** @type {Resolver} */\n  function resolveAllText(events, context) {\n    let index = -1;\n    /** @type {number | undefined} */\n    let enter;\n\n    // A rather boring computation (to merge adjacent `data` events) which\n    // improves mm performance by 29%.\n    while (++index <= events.length) {\n      if (enter === undefined) {\n        if (events[index] && events[index][1].type === \"data\") {\n          enter = index;\n          index++;\n        }\n      } else if (!events[index] || events[index][1].type !== \"data\") {\n        // Don’t do anything if there is one data token.\n        if (index !== enter + 2) {\n          events[enter][1].end = events[index - 1][1].end;\n          events.splice(enter + 2, index - enter - 2);\n          index = enter + 2;\n        }\n        enter = undefined;\n      }\n    }\n    return extraResolver ? extraResolver(events, context) : events;\n  }\n}\n\n/**\r\n * A rather ugly set of instructions which again looks at chunks in the input\r\n * stream.\r\n * The reason to do this here is that it is *much* faster to parse in reverse.\r\n * And that we can’t hook into `null` to split the line suffix before an EOF.\r\n * To do: figure out if we can make this into a clean utility, or even in core.\r\n * As it will be useful for GFMs literal autolink extension (and maybe even\r\n * tables?)\r\n *\r\n * @type {Resolver}\r\n */\nfunction resolveAllLineSuffixes(events, context) {\n  let eventIndex = 0; // Skip first.\n\n  while (++eventIndex <= events.length) {\n    if ((eventIndex === events.length || events[eventIndex][1].type === \"lineEnding\") && events[eventIndex - 1][1].type === \"data\") {\n      const data = events[eventIndex - 1][1];\n      const chunks = context.sliceStream(data);\n      let index = chunks.length;\n      let bufferIndex = -1;\n      let size = 0;\n      /** @type {boolean | undefined} */\n      let tabs;\n      while (index--) {\n        const chunk = chunks[index];\n        if (typeof chunk === 'string') {\n          bufferIndex = chunk.length;\n          while (chunk.charCodeAt(bufferIndex - 1) === 32) {\n            size++;\n            bufferIndex--;\n          }\n          if (bufferIndex) break;\n          bufferIndex = -1;\n        }\n        // Number\n        else if (chunk === -2) {\n          tabs = true;\n          size++;\n        } else if (chunk === -1) {\n          // Empty\n        } else {\n          // Replacement character, exit.\n          index++;\n          break;\n        }\n      }\n      if (size) {\n        const token = {\n          type: eventIndex === events.length || tabs || size < 2 ? \"lineSuffix\" : \"hardBreakTrailing\",\n          start: {\n            _bufferIndex: index ? bufferIndex : data.start._bufferIndex + bufferIndex,\n            _index: data.start._index + index,\n            line: data.end.line,\n            column: data.end.column - size,\n            offset: data.end.offset - size\n          },\n          end: {\n            ...data.end\n          }\n        };\n        data.end = {\n          ...token.start\n        };\n        if (data.start.offset === data.end.offset) {\n          Object.assign(data, token);\n        } else {\n          events.splice(eventIndex, 0, ['enter', token, context], ['exit', token, context]);\n          eventIndex += 2;\n        }\n      }\n      eventIndex++;\n    }\n  }\n  return events;\n}","map":{"version":3,"names":["resolver","resolveAll","createResolver","string","initializeFactory","text","field","resolveAllLineSuffixes","undefined","tokenize","initializeText","effects","self","constructs","parser","attempt","start","notText","code","atBreak","consume","enter","data","exit","list","index","length","item","previous","call","extraResolver","resolveAllText","events","context","type","end","splice","eventIndex","chunks","sliceStream","bufferIndex","size","tabs","chunk","charCodeAt","token","_bufferIndex","_index","line","column","offset","Object","assign"],"sources":["C:/Users/LENOVO/OneDrive/Masaüstü/Bitirme/bitirme/frontend/doc-manager-ui/node_modules/micromark/lib/initialize/text.js"],"sourcesContent":["/**\r\n * @import {\r\n *   Code,\r\n *   InitialConstruct,\r\n *   Initializer,\r\n *   Resolver,\r\n *   State,\r\n *   TokenizeContext\r\n * } from 'micromark-util-types'\r\n */\r\n\r\nexport const resolver = {\r\n  resolveAll: createResolver()\r\n};\r\nexport const string = initializeFactory('string');\r\nexport const text = initializeFactory('text');\r\n\r\n/**\r\n * @param {'string' | 'text'} field\r\n *   Field.\r\n * @returns {InitialConstruct}\r\n *   Construct.\r\n */\r\nfunction initializeFactory(field) {\r\n  return {\r\n    resolveAll: createResolver(field === 'text' ? resolveAllLineSuffixes : undefined),\r\n    tokenize: initializeText\r\n  };\r\n\r\n  /**\r\n   * @this {TokenizeContext}\r\n   *   Context.\r\n   * @type {Initializer}\r\n   */\r\n  function initializeText(effects) {\r\n    const self = this;\r\n    const constructs = this.parser.constructs[field];\r\n    const text = effects.attempt(constructs, start, notText);\r\n    return start;\r\n\r\n    /** @type {State} */\r\n    function start(code) {\r\n      return atBreak(code) ? text(code) : notText(code);\r\n    }\r\n\r\n    /** @type {State} */\r\n    function notText(code) {\r\n      if (code === null) {\r\n        effects.consume(code);\r\n        return;\r\n      }\r\n      effects.enter(\"data\");\r\n      effects.consume(code);\r\n      return data;\r\n    }\r\n\r\n    /** @type {State} */\r\n    function data(code) {\r\n      if (atBreak(code)) {\r\n        effects.exit(\"data\");\r\n        return text(code);\r\n      }\r\n\r\n      // Data.\r\n      effects.consume(code);\r\n      return data;\r\n    }\r\n\r\n    /**\r\n     * @param {Code} code\r\n     *   Code.\r\n     * @returns {boolean}\r\n     *   Whether the code is a break.\r\n     */\r\n    function atBreak(code) {\r\n      if (code === null) {\r\n        return true;\r\n      }\r\n      const list = constructs[code];\r\n      let index = -1;\r\n      if (list) {\r\n        // Always populated by defaults.\r\n\r\n        while (++index < list.length) {\r\n          const item = list[index];\r\n          if (!item.previous || item.previous.call(self, self.previous)) {\r\n            return true;\r\n          }\r\n        }\r\n      }\r\n      return false;\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * @param {Resolver | undefined} [extraResolver]\r\n *   Resolver.\r\n * @returns {Resolver}\r\n *   Resolver.\r\n */\r\nfunction createResolver(extraResolver) {\r\n  return resolveAllText;\r\n\r\n  /** @type {Resolver} */\r\n  function resolveAllText(events, context) {\r\n    let index = -1;\r\n    /** @type {number | undefined} */\r\n    let enter;\r\n\r\n    // A rather boring computation (to merge adjacent `data` events) which\r\n    // improves mm performance by 29%.\r\n    while (++index <= events.length) {\r\n      if (enter === undefined) {\r\n        if (events[index] && events[index][1].type === \"data\") {\r\n          enter = index;\r\n          index++;\r\n        }\r\n      } else if (!events[index] || events[index][1].type !== \"data\") {\r\n        // Don’t do anything if there is one data token.\r\n        if (index !== enter + 2) {\r\n          events[enter][1].end = events[index - 1][1].end;\r\n          events.splice(enter + 2, index - enter - 2);\r\n          index = enter + 2;\r\n        }\r\n        enter = undefined;\r\n      }\r\n    }\r\n    return extraResolver ? extraResolver(events, context) : events;\r\n  }\r\n}\r\n\r\n/**\r\n * A rather ugly set of instructions which again looks at chunks in the input\r\n * stream.\r\n * The reason to do this here is that it is *much* faster to parse in reverse.\r\n * And that we can’t hook into `null` to split the line suffix before an EOF.\r\n * To do: figure out if we can make this into a clean utility, or even in core.\r\n * As it will be useful for GFMs literal autolink extension (and maybe even\r\n * tables?)\r\n *\r\n * @type {Resolver}\r\n */\r\nfunction resolveAllLineSuffixes(events, context) {\r\n  let eventIndex = 0; // Skip first.\r\n\r\n  while (++eventIndex <= events.length) {\r\n    if ((eventIndex === events.length || events[eventIndex][1].type === \"lineEnding\") && events[eventIndex - 1][1].type === \"data\") {\r\n      const data = events[eventIndex - 1][1];\r\n      const chunks = context.sliceStream(data);\r\n      let index = chunks.length;\r\n      let bufferIndex = -1;\r\n      let size = 0;\r\n      /** @type {boolean | undefined} */\r\n      let tabs;\r\n      while (index--) {\r\n        const chunk = chunks[index];\r\n        if (typeof chunk === 'string') {\r\n          bufferIndex = chunk.length;\r\n          while (chunk.charCodeAt(bufferIndex - 1) === 32) {\r\n            size++;\r\n            bufferIndex--;\r\n          }\r\n          if (bufferIndex) break;\r\n          bufferIndex = -1;\r\n        }\r\n        // Number\r\n        else if (chunk === -2) {\r\n          tabs = true;\r\n          size++;\r\n        } else if (chunk === -1) {\r\n          // Empty\r\n        } else {\r\n          // Replacement character, exit.\r\n          index++;\r\n          break;\r\n        }\r\n      }\r\n      if (size) {\r\n        const token = {\r\n          type: eventIndex === events.length || tabs || size < 2 ? \"lineSuffix\" : \"hardBreakTrailing\",\r\n          start: {\r\n            _bufferIndex: index ? bufferIndex : data.start._bufferIndex + bufferIndex,\r\n            _index: data.start._index + index,\r\n            line: data.end.line,\r\n            column: data.end.column - size,\r\n            offset: data.end.offset - size\r\n          },\r\n          end: {\r\n            ...data.end\r\n          }\r\n        };\r\n        data.end = {\r\n          ...token.start\r\n        };\r\n        if (data.start.offset === data.end.offset) {\r\n          Object.assign(data, token);\r\n        } else {\r\n          events.splice(eventIndex, 0, ['enter', token, context], ['exit', token, context]);\r\n          eventIndex += 2;\r\n        }\r\n      }\r\n      eventIndex++;\r\n    }\r\n  }\r\n  return events;\r\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}