{"ast":null,"code":"/**\r\n * @import {\r\n *   Code,\r\n *   Construct,\r\n *   Event,\r\n *   Point,\r\n *   Resolver,\r\n *   State,\r\n *   TokenizeContext,\r\n *   Tokenizer,\r\n *   Token\r\n * } from 'micromark-util-types'\r\n */\n\nimport { push, splice } from 'micromark-util-chunked';\nimport { classifyCharacter } from 'micromark-util-classify-character';\nimport { resolveAll } from 'micromark-util-resolve-all';\n/** @type {Construct} */\nexport const attention = {\n  name: 'attention',\n  resolveAll: resolveAllAttention,\n  tokenize: tokenizeAttention\n};\n\n/**\r\n * Take all events and resolve attention to emphasis or strong.\r\n *\r\n * @type {Resolver}\r\n */\n// eslint-disable-next-line complexity\nfunction resolveAllAttention(events, context) {\n  let index = -1;\n  /** @type {number} */\n  let open;\n  /** @type {Token} */\n  let group;\n  /** @type {Token} */\n  let text;\n  /** @type {Token} */\n  let openingSequence;\n  /** @type {Token} */\n  let closingSequence;\n  /** @type {number} */\n  let use;\n  /** @type {Array<Event>} */\n  let nextEvents;\n  /** @type {number} */\n  let offset;\n\n  // Walk through all events.\n  //\n  // Note: performance of this is fine on an mb of normal markdown, but it’s\n  // a bottleneck for malicious stuff.\n  while (++index < events.length) {\n    // Find a token that can close.\n    if (events[index][0] === 'enter' && events[index][1].type === 'attentionSequence' && events[index][1]._close) {\n      open = index;\n\n      // Now walk back to find an opener.\n      while (open--) {\n        // Find a token that can open the closer.\n        if (events[open][0] === 'exit' && events[open][1].type === 'attentionSequence' && events[open][1]._open &&\n        // If the markers are the same:\n        context.sliceSerialize(events[open][1]).charCodeAt(0) === context.sliceSerialize(events[index][1]).charCodeAt(0)) {\n          // If the opening can close or the closing can open,\n          // and the close size *is not* a multiple of three,\n          // but the sum of the opening and closing size *is* multiple of three,\n          // then don’t match.\n          if ((events[open][1]._close || events[index][1]._open) && (events[index][1].end.offset - events[index][1].start.offset) % 3 && !((events[open][1].end.offset - events[open][1].start.offset + events[index][1].end.offset - events[index][1].start.offset) % 3)) {\n            continue;\n          }\n\n          // Number of markers to use from the sequence.\n          use = events[open][1].end.offset - events[open][1].start.offset > 1 && events[index][1].end.offset - events[index][1].start.offset > 1 ? 2 : 1;\n          const start = {\n            ...events[open][1].end\n          };\n          const end = {\n            ...events[index][1].start\n          };\n          movePoint(start, -use);\n          movePoint(end, use);\n          openingSequence = {\n            type: use > 1 ? \"strongSequence\" : \"emphasisSequence\",\n            start,\n            end: {\n              ...events[open][1].end\n            }\n          };\n          closingSequence = {\n            type: use > 1 ? \"strongSequence\" : \"emphasisSequence\",\n            start: {\n              ...events[index][1].start\n            },\n            end\n          };\n          text = {\n            type: use > 1 ? \"strongText\" : \"emphasisText\",\n            start: {\n              ...events[open][1].end\n            },\n            end: {\n              ...events[index][1].start\n            }\n          };\n          group = {\n            type: use > 1 ? \"strong\" : \"emphasis\",\n            start: {\n              ...openingSequence.start\n            },\n            end: {\n              ...closingSequence.end\n            }\n          };\n          events[open][1].end = {\n            ...openingSequence.start\n          };\n          events[index][1].start = {\n            ...closingSequence.end\n          };\n          nextEvents = [];\n\n          // If there are more markers in the opening, add them before.\n          if (events[open][1].end.offset - events[open][1].start.offset) {\n            nextEvents = push(nextEvents, [['enter', events[open][1], context], ['exit', events[open][1], context]]);\n          }\n\n          // Opening.\n          nextEvents = push(nextEvents, [['enter', group, context], ['enter', openingSequence, context], ['exit', openingSequence, context], ['enter', text, context]]);\n\n          // Always populated by defaults.\n\n          // Between.\n          nextEvents = push(nextEvents, resolveAll(context.parser.constructs.insideSpan.null, events.slice(open + 1, index), context));\n\n          // Closing.\n          nextEvents = push(nextEvents, [['exit', text, context], ['enter', closingSequence, context], ['exit', closingSequence, context], ['exit', group, context]]);\n\n          // If there are more markers in the closing, add them after.\n          if (events[index][1].end.offset - events[index][1].start.offset) {\n            offset = 2;\n            nextEvents = push(nextEvents, [['enter', events[index][1], context], ['exit', events[index][1], context]]);\n          } else {\n            offset = 0;\n          }\n          splice(events, open - 1, index - open + 3, nextEvents);\n          index = open + nextEvents.length - offset - 2;\n          break;\n        }\n      }\n    }\n  }\n\n  // Remove remaining sequences.\n  index = -1;\n  while (++index < events.length) {\n    if (events[index][1].type === 'attentionSequence') {\n      events[index][1].type = 'data';\n    }\n  }\n  return events;\n}\n\n/**\r\n * @this {TokenizeContext}\r\n *   Context.\r\n * @type {Tokenizer}\r\n */\nfunction tokenizeAttention(effects, ok) {\n  const attentionMarkers = this.parser.constructs.attentionMarkers.null;\n  const previous = this.previous;\n  const before = classifyCharacter(previous);\n\n  /** @type {NonNullable<Code>} */\n  let marker;\n  return start;\n\n  /**\r\n   * Before a sequence.\r\n   *\r\n   * ```markdown\r\n   * > | **\r\n   *     ^\r\n   * ```\r\n   *\r\n   * @type {State}\r\n   */\n  function start(code) {\n    marker = code;\n    effects.enter('attentionSequence');\n    return inside(code);\n  }\n\n  /**\r\n   * In a sequence.\r\n   *\r\n   * ```markdown\r\n   * > | **\r\n   *     ^^\r\n   * ```\r\n   *\r\n   * @type {State}\r\n   */\n  function inside(code) {\n    if (code === marker) {\n      effects.consume(code);\n      return inside;\n    }\n    const token = effects.exit('attentionSequence');\n\n    // To do: next major: move this to resolver, just like `markdown-rs`.\n    const after = classifyCharacter(code);\n\n    // Always populated by defaults.\n\n    const open = !after || after === 2 && before || attentionMarkers.includes(code);\n    const close = !before || before === 2 && after || attentionMarkers.includes(previous);\n    token._open = Boolean(marker === 42 ? open : open && (before || !close));\n    token._close = Boolean(marker === 42 ? close : close && (after || !open));\n    return ok(code);\n  }\n}\n\n/**\r\n * Move a point a bit.\r\n *\r\n * Note: `move` only works inside lines! It’s not possible to move past other\r\n * chunks (replacement characters, tabs, or line endings).\r\n *\r\n * @param {Point} point\r\n *   Point.\r\n * @param {number} offset\r\n *   Amount to move.\r\n * @returns {undefined}\r\n *   Nothing.\r\n */\nfunction movePoint(point, offset) {\n  point.column += offset;\n  point.offset += offset;\n  point._bufferIndex += offset;\n}","map":{"version":3,"names":["push","splice","classifyCharacter","resolveAll","attention","name","resolveAllAttention","tokenize","tokenizeAttention","events","context","index","open","group","text","openingSequence","closingSequence","use","nextEvents","offset","length","type","_close","_open","sliceSerialize","charCodeAt","end","start","movePoint","parser","constructs","insideSpan","null","slice","effects","ok","attentionMarkers","previous","before","marker","code","enter","inside","consume","token","exit","after","includes","close","Boolean","point","column","_bufferIndex"],"sources":["C:/Users/LENOVO/OneDrive/Masaüstü/Bitirme/bitirme/frontend/doc-manager-ui/node_modules/micromark-core-commonmark/lib/attention.js"],"sourcesContent":["/**\r\n * @import {\r\n *   Code,\r\n *   Construct,\r\n *   Event,\r\n *   Point,\r\n *   Resolver,\r\n *   State,\r\n *   TokenizeContext,\r\n *   Tokenizer,\r\n *   Token\r\n * } from 'micromark-util-types'\r\n */\r\n\r\nimport { push, splice } from 'micromark-util-chunked';\r\nimport { classifyCharacter } from 'micromark-util-classify-character';\r\nimport { resolveAll } from 'micromark-util-resolve-all';\r\n/** @type {Construct} */\r\nexport const attention = {\r\n  name: 'attention',\r\n  resolveAll: resolveAllAttention,\r\n  tokenize: tokenizeAttention\r\n};\r\n\r\n/**\r\n * Take all events and resolve attention to emphasis or strong.\r\n *\r\n * @type {Resolver}\r\n */\r\n// eslint-disable-next-line complexity\r\nfunction resolveAllAttention(events, context) {\r\n  let index = -1;\r\n  /** @type {number} */\r\n  let open;\r\n  /** @type {Token} */\r\n  let group;\r\n  /** @type {Token} */\r\n  let text;\r\n  /** @type {Token} */\r\n  let openingSequence;\r\n  /** @type {Token} */\r\n  let closingSequence;\r\n  /** @type {number} */\r\n  let use;\r\n  /** @type {Array<Event>} */\r\n  let nextEvents;\r\n  /** @type {number} */\r\n  let offset;\r\n\r\n  // Walk through all events.\r\n  //\r\n  // Note: performance of this is fine on an mb of normal markdown, but it’s\r\n  // a bottleneck for malicious stuff.\r\n  while (++index < events.length) {\r\n    // Find a token that can close.\r\n    if (events[index][0] === 'enter' && events[index][1].type === 'attentionSequence' && events[index][1]._close) {\r\n      open = index;\r\n\r\n      // Now walk back to find an opener.\r\n      while (open--) {\r\n        // Find a token that can open the closer.\r\n        if (events[open][0] === 'exit' && events[open][1].type === 'attentionSequence' && events[open][1]._open &&\r\n        // If the markers are the same:\r\n        context.sliceSerialize(events[open][1]).charCodeAt(0) === context.sliceSerialize(events[index][1]).charCodeAt(0)) {\r\n          // If the opening can close or the closing can open,\r\n          // and the close size *is not* a multiple of three,\r\n          // but the sum of the opening and closing size *is* multiple of three,\r\n          // then don’t match.\r\n          if ((events[open][1]._close || events[index][1]._open) && (events[index][1].end.offset - events[index][1].start.offset) % 3 && !((events[open][1].end.offset - events[open][1].start.offset + events[index][1].end.offset - events[index][1].start.offset) % 3)) {\r\n            continue;\r\n          }\r\n\r\n          // Number of markers to use from the sequence.\r\n          use = events[open][1].end.offset - events[open][1].start.offset > 1 && events[index][1].end.offset - events[index][1].start.offset > 1 ? 2 : 1;\r\n          const start = {\r\n            ...events[open][1].end\r\n          };\r\n          const end = {\r\n            ...events[index][1].start\r\n          };\r\n          movePoint(start, -use);\r\n          movePoint(end, use);\r\n          openingSequence = {\r\n            type: use > 1 ? \"strongSequence\" : \"emphasisSequence\",\r\n            start,\r\n            end: {\r\n              ...events[open][1].end\r\n            }\r\n          };\r\n          closingSequence = {\r\n            type: use > 1 ? \"strongSequence\" : \"emphasisSequence\",\r\n            start: {\r\n              ...events[index][1].start\r\n            },\r\n            end\r\n          };\r\n          text = {\r\n            type: use > 1 ? \"strongText\" : \"emphasisText\",\r\n            start: {\r\n              ...events[open][1].end\r\n            },\r\n            end: {\r\n              ...events[index][1].start\r\n            }\r\n          };\r\n          group = {\r\n            type: use > 1 ? \"strong\" : \"emphasis\",\r\n            start: {\r\n              ...openingSequence.start\r\n            },\r\n            end: {\r\n              ...closingSequence.end\r\n            }\r\n          };\r\n          events[open][1].end = {\r\n            ...openingSequence.start\r\n          };\r\n          events[index][1].start = {\r\n            ...closingSequence.end\r\n          };\r\n          nextEvents = [];\r\n\r\n          // If there are more markers in the opening, add them before.\r\n          if (events[open][1].end.offset - events[open][1].start.offset) {\r\n            nextEvents = push(nextEvents, [['enter', events[open][1], context], ['exit', events[open][1], context]]);\r\n          }\r\n\r\n          // Opening.\r\n          nextEvents = push(nextEvents, [['enter', group, context], ['enter', openingSequence, context], ['exit', openingSequence, context], ['enter', text, context]]);\r\n\r\n          // Always populated by defaults.\r\n\r\n          // Between.\r\n          nextEvents = push(nextEvents, resolveAll(context.parser.constructs.insideSpan.null, events.slice(open + 1, index), context));\r\n\r\n          // Closing.\r\n          nextEvents = push(nextEvents, [['exit', text, context], ['enter', closingSequence, context], ['exit', closingSequence, context], ['exit', group, context]]);\r\n\r\n          // If there are more markers in the closing, add them after.\r\n          if (events[index][1].end.offset - events[index][1].start.offset) {\r\n            offset = 2;\r\n            nextEvents = push(nextEvents, [['enter', events[index][1], context], ['exit', events[index][1], context]]);\r\n          } else {\r\n            offset = 0;\r\n          }\r\n          splice(events, open - 1, index - open + 3, nextEvents);\r\n          index = open + nextEvents.length - offset - 2;\r\n          break;\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  // Remove remaining sequences.\r\n  index = -1;\r\n  while (++index < events.length) {\r\n    if (events[index][1].type === 'attentionSequence') {\r\n      events[index][1].type = 'data';\r\n    }\r\n  }\r\n  return events;\r\n}\r\n\r\n/**\r\n * @this {TokenizeContext}\r\n *   Context.\r\n * @type {Tokenizer}\r\n */\r\nfunction tokenizeAttention(effects, ok) {\r\n  const attentionMarkers = this.parser.constructs.attentionMarkers.null;\r\n  const previous = this.previous;\r\n  const before = classifyCharacter(previous);\r\n\r\n  /** @type {NonNullable<Code>} */\r\n  let marker;\r\n  return start;\r\n\r\n  /**\r\n   * Before a sequence.\r\n   *\r\n   * ```markdown\r\n   * > | **\r\n   *     ^\r\n   * ```\r\n   *\r\n   * @type {State}\r\n   */\r\n  function start(code) {\r\n    marker = code;\r\n    effects.enter('attentionSequence');\r\n    return inside(code);\r\n  }\r\n\r\n  /**\r\n   * In a sequence.\r\n   *\r\n   * ```markdown\r\n   * > | **\r\n   *     ^^\r\n   * ```\r\n   *\r\n   * @type {State}\r\n   */\r\n  function inside(code) {\r\n    if (code === marker) {\r\n      effects.consume(code);\r\n      return inside;\r\n    }\r\n    const token = effects.exit('attentionSequence');\r\n\r\n    // To do: next major: move this to resolver, just like `markdown-rs`.\r\n    const after = classifyCharacter(code);\r\n\r\n    // Always populated by defaults.\r\n\r\n    const open = !after || after === 2 && before || attentionMarkers.includes(code);\r\n    const close = !before || before === 2 && after || attentionMarkers.includes(previous);\r\n    token._open = Boolean(marker === 42 ? open : open && (before || !close));\r\n    token._close = Boolean(marker === 42 ? close : close && (after || !open));\r\n    return ok(code);\r\n  }\r\n}\r\n\r\n/**\r\n * Move a point a bit.\r\n *\r\n * Note: `move` only works inside lines! It’s not possible to move past other\r\n * chunks (replacement characters, tabs, or line endings).\r\n *\r\n * @param {Point} point\r\n *   Point.\r\n * @param {number} offset\r\n *   Amount to move.\r\n * @returns {undefined}\r\n *   Nothing.\r\n */\r\nfunction movePoint(point, offset) {\r\n  point.column += offset;\r\n  point.offset += offset;\r\n  point._bufferIndex += offset;\r\n}"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,SAASA,IAAI,EAAEC,MAAM,QAAQ,wBAAwB;AACrD,SAASC,iBAAiB,QAAQ,mCAAmC;AACrE,SAASC,UAAU,QAAQ,4BAA4B;AACvD;AACA,OAAO,MAAMC,SAAS,GAAG;EACvBC,IAAI,EAAE,WAAW;EACjBF,UAAU,EAAEG,mBAAmB;EAC/BC,QAAQ,EAAEC;AACZ,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA,SAASF,mBAAmBA,CAACG,MAAM,EAAEC,OAAO,EAAE;EAC5C,IAAIC,KAAK,GAAG,CAAC,CAAC;EACd;EACA,IAAIC,IAAI;EACR;EACA,IAAIC,KAAK;EACT;EACA,IAAIC,IAAI;EACR;EACA,IAAIC,eAAe;EACnB;EACA,IAAIC,eAAe;EACnB;EACA,IAAIC,GAAG;EACP;EACA,IAAIC,UAAU;EACd;EACA,IAAIC,MAAM;;EAEV;EACA;EACA;EACA;EACA,OAAO,EAAER,KAAK,GAAGF,MAAM,CAACW,MAAM,EAAE;IAC9B;IACA,IAAIX,MAAM,CAACE,KAAK,CAAC,CAAC,CAAC,CAAC,KAAK,OAAO,IAAIF,MAAM,CAACE,KAAK,CAAC,CAAC,CAAC,CAAC,CAACU,IAAI,KAAK,mBAAmB,IAAIZ,MAAM,CAACE,KAAK,CAAC,CAAC,CAAC,CAAC,CAACW,MAAM,EAAE;MAC5GV,IAAI,GAAGD,KAAK;;MAEZ;MACA,OAAOC,IAAI,EAAE,EAAE;QACb;QACA,IAAIH,MAAM,CAACG,IAAI,CAAC,CAAC,CAAC,CAAC,KAAK,MAAM,IAAIH,MAAM,CAACG,IAAI,CAAC,CAAC,CAAC,CAAC,CAACS,IAAI,KAAK,mBAAmB,IAAIZ,MAAM,CAACG,IAAI,CAAC,CAAC,CAAC,CAAC,CAACW,KAAK;QACvG;QACAb,OAAO,CAACc,cAAc,CAACf,MAAM,CAACG,IAAI,CAAC,CAAC,CAAC,CAAC,CAAC,CAACa,UAAU,CAAC,CAAC,CAAC,KAAKf,OAAO,CAACc,cAAc,CAACf,MAAM,CAACE,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,CAACc,UAAU,CAAC,CAAC,CAAC,EAAE;UAChH;UACA;UACA;UACA;UACA,IAAI,CAAChB,MAAM,CAACG,IAAI,CAAC,CAAC,CAAC,CAAC,CAACU,MAAM,IAAIb,MAAM,CAACE,KAAK,CAAC,CAAC,CAAC,CAAC,CAACY,KAAK,KAAK,CAACd,MAAM,CAACE,KAAK,CAAC,CAAC,CAAC,CAAC,CAACe,GAAG,CAACP,MAAM,GAAGV,MAAM,CAACE,KAAK,CAAC,CAAC,CAAC,CAAC,CAACgB,KAAK,CAACR,MAAM,IAAI,CAAC,IAAI,EAAE,CAACV,MAAM,CAACG,IAAI,CAAC,CAAC,CAAC,CAAC,CAACc,GAAG,CAACP,MAAM,GAAGV,MAAM,CAACG,IAAI,CAAC,CAAC,CAAC,CAAC,CAACe,KAAK,CAACR,MAAM,GAAGV,MAAM,CAACE,KAAK,CAAC,CAAC,CAAC,CAAC,CAACe,GAAG,CAACP,MAAM,GAAGV,MAAM,CAACE,KAAK,CAAC,CAAC,CAAC,CAAC,CAACgB,KAAK,CAACR,MAAM,IAAI,CAAC,CAAC,EAAE;YAC/P;UACF;;UAEA;UACAF,GAAG,GAAGR,MAAM,CAACG,IAAI,CAAC,CAAC,CAAC,CAAC,CAACc,GAAG,CAACP,MAAM,GAAGV,MAAM,CAACG,IAAI,CAAC,CAAC,CAAC,CAAC,CAACe,KAAK,CAACR,MAAM,GAAG,CAAC,IAAIV,MAAM,CAACE,KAAK,CAAC,CAAC,CAAC,CAAC,CAACe,GAAG,CAACP,MAAM,GAAGV,MAAM,CAACE,KAAK,CAAC,CAAC,CAAC,CAAC,CAACgB,KAAK,CAACR,MAAM,GAAG,CAAC,GAAG,CAAC,GAAG,CAAC;UAC9I,MAAMQ,KAAK,GAAG;YACZ,GAAGlB,MAAM,CAACG,IAAI,CAAC,CAAC,CAAC,CAAC,CAACc;UACrB,CAAC;UACD,MAAMA,GAAG,GAAG;YACV,GAAGjB,MAAM,CAACE,KAAK,CAAC,CAAC,CAAC,CAAC,CAACgB;UACtB,CAAC;UACDC,SAAS,CAACD,KAAK,EAAE,CAACV,GAAG,CAAC;UACtBW,SAAS,CAACF,GAAG,EAAET,GAAG,CAAC;UACnBF,eAAe,GAAG;YAChBM,IAAI,EAAEJ,GAAG,GAAG,CAAC,GAAG,gBAAgB,GAAG,kBAAkB;YACrDU,KAAK;YACLD,GAAG,EAAE;cACH,GAAGjB,MAAM,CAACG,IAAI,CAAC,CAAC,CAAC,CAAC,CAACc;YACrB;UACF,CAAC;UACDV,eAAe,GAAG;YAChBK,IAAI,EAAEJ,GAAG,GAAG,CAAC,GAAG,gBAAgB,GAAG,kBAAkB;YACrDU,KAAK,EAAE;cACL,GAAGlB,MAAM,CAACE,KAAK,CAAC,CAAC,CAAC,CAAC,CAACgB;YACtB,CAAC;YACDD;UACF,CAAC;UACDZ,IAAI,GAAG;YACLO,IAAI,EAAEJ,GAAG,GAAG,CAAC,GAAG,YAAY,GAAG,cAAc;YAC7CU,KAAK,EAAE;cACL,GAAGlB,MAAM,CAACG,IAAI,CAAC,CAAC,CAAC,CAAC,CAACc;YACrB,CAAC;YACDA,GAAG,EAAE;cACH,GAAGjB,MAAM,CAACE,KAAK,CAAC,CAAC,CAAC,CAAC,CAACgB;YACtB;UACF,CAAC;UACDd,KAAK,GAAG;YACNQ,IAAI,EAAEJ,GAAG,GAAG,CAAC,GAAG,QAAQ,GAAG,UAAU;YACrCU,KAAK,EAAE;cACL,GAAGZ,eAAe,CAACY;YACrB,CAAC;YACDD,GAAG,EAAE;cACH,GAAGV,eAAe,CAACU;YACrB;UACF,CAAC;UACDjB,MAAM,CAACG,IAAI,CAAC,CAAC,CAAC,CAAC,CAACc,GAAG,GAAG;YACpB,GAAGX,eAAe,CAACY;UACrB,CAAC;UACDlB,MAAM,CAACE,KAAK,CAAC,CAAC,CAAC,CAAC,CAACgB,KAAK,GAAG;YACvB,GAAGX,eAAe,CAACU;UACrB,CAAC;UACDR,UAAU,GAAG,EAAE;;UAEf;UACA,IAAIT,MAAM,CAACG,IAAI,CAAC,CAAC,CAAC,CAAC,CAACc,GAAG,CAACP,MAAM,GAAGV,MAAM,CAACG,IAAI,CAAC,CAAC,CAAC,CAAC,CAACe,KAAK,CAACR,MAAM,EAAE;YAC7DD,UAAU,GAAGlB,IAAI,CAACkB,UAAU,EAAE,CAAC,CAAC,OAAO,EAAET,MAAM,CAACG,IAAI,CAAC,CAAC,CAAC,CAAC,EAAEF,OAAO,CAAC,EAAE,CAAC,MAAM,EAAED,MAAM,CAACG,IAAI,CAAC,CAAC,CAAC,CAAC,EAAEF,OAAO,CAAC,CAAC,CAAC;UAC1G;;UAEA;UACAQ,UAAU,GAAGlB,IAAI,CAACkB,UAAU,EAAE,CAAC,CAAC,OAAO,EAAEL,KAAK,EAAEH,OAAO,CAAC,EAAE,CAAC,OAAO,EAAEK,eAAe,EAAEL,OAAO,CAAC,EAAE,CAAC,MAAM,EAAEK,eAAe,EAAEL,OAAO,CAAC,EAAE,CAAC,OAAO,EAAEI,IAAI,EAAEJ,OAAO,CAAC,CAAC,CAAC;;UAE7J;;UAEA;UACAQ,UAAU,GAAGlB,IAAI,CAACkB,UAAU,EAAEf,UAAU,CAACO,OAAO,CAACmB,MAAM,CAACC,UAAU,CAACC,UAAU,CAACC,IAAI,EAAEvB,MAAM,CAACwB,KAAK,CAACrB,IAAI,GAAG,CAAC,EAAED,KAAK,CAAC,EAAED,OAAO,CAAC,CAAC;;UAE5H;UACAQ,UAAU,GAAGlB,IAAI,CAACkB,UAAU,EAAE,CAAC,CAAC,MAAM,EAAEJ,IAAI,EAAEJ,OAAO,CAAC,EAAE,CAAC,OAAO,EAAEM,eAAe,EAAEN,OAAO,CAAC,EAAE,CAAC,MAAM,EAAEM,eAAe,EAAEN,OAAO,CAAC,EAAE,CAAC,MAAM,EAAEG,KAAK,EAAEH,OAAO,CAAC,CAAC,CAAC;;UAE3J;UACA,IAAID,MAAM,CAACE,KAAK,CAAC,CAAC,CAAC,CAAC,CAACe,GAAG,CAACP,MAAM,GAAGV,MAAM,CAACE,KAAK,CAAC,CAAC,CAAC,CAAC,CAACgB,KAAK,CAACR,MAAM,EAAE;YAC/DA,MAAM,GAAG,CAAC;YACVD,UAAU,GAAGlB,IAAI,CAACkB,UAAU,EAAE,CAAC,CAAC,OAAO,EAAET,MAAM,CAACE,KAAK,CAAC,CAAC,CAAC,CAAC,EAAED,OAAO,CAAC,EAAE,CAAC,MAAM,EAAED,MAAM,CAACE,KAAK,CAAC,CAAC,CAAC,CAAC,EAAED,OAAO,CAAC,CAAC,CAAC;UAC5G,CAAC,MAAM;YACLS,MAAM,GAAG,CAAC;UACZ;UACAlB,MAAM,CAACQ,MAAM,EAAEG,IAAI,GAAG,CAAC,EAAED,KAAK,GAAGC,IAAI,GAAG,CAAC,EAAEM,UAAU,CAAC;UACtDP,KAAK,GAAGC,IAAI,GAAGM,UAAU,CAACE,MAAM,GAAGD,MAAM,GAAG,CAAC;UAC7C;QACF;MACF;IACF;EACF;;EAEA;EACAR,KAAK,GAAG,CAAC,CAAC;EACV,OAAO,EAAEA,KAAK,GAAGF,MAAM,CAACW,MAAM,EAAE;IAC9B,IAAIX,MAAM,CAACE,KAAK,CAAC,CAAC,CAAC,CAAC,CAACU,IAAI,KAAK,mBAAmB,EAAE;MACjDZ,MAAM,CAACE,KAAK,CAAC,CAAC,CAAC,CAAC,CAACU,IAAI,GAAG,MAAM;IAChC;EACF;EACA,OAAOZ,MAAM;AACf;;AAEA;AACA;AACA;AACA;AACA;AACA,SAASD,iBAAiBA,CAAC0B,OAAO,EAAEC,EAAE,EAAE;EACtC,MAAMC,gBAAgB,GAAG,IAAI,CAACP,MAAM,CAACC,UAAU,CAACM,gBAAgB,CAACJ,IAAI;EACrE,MAAMK,QAAQ,GAAG,IAAI,CAACA,QAAQ;EAC9B,MAAMC,MAAM,GAAGpC,iBAAiB,CAACmC,QAAQ,CAAC;;EAE1C;EACA,IAAIE,MAAM;EACV,OAAOZ,KAAK;;EAEZ;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACE,SAASA,KAAKA,CAACa,IAAI,EAAE;IACnBD,MAAM,GAAGC,IAAI;IACbN,OAAO,CAACO,KAAK,CAAC,mBAAmB,CAAC;IAClC,OAAOC,MAAM,CAACF,IAAI,CAAC;EACrB;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACE,SAASE,MAAMA,CAACF,IAAI,EAAE;IACpB,IAAIA,IAAI,KAAKD,MAAM,EAAE;MACnBL,OAAO,CAACS,OAAO,CAACH,IAAI,CAAC;MACrB,OAAOE,MAAM;IACf;IACA,MAAME,KAAK,GAAGV,OAAO,CAACW,IAAI,CAAC,mBAAmB,CAAC;;IAE/C;IACA,MAAMC,KAAK,GAAG5C,iBAAiB,CAACsC,IAAI,CAAC;;IAErC;;IAEA,MAAM5B,IAAI,GAAG,CAACkC,KAAK,IAAIA,KAAK,KAAK,CAAC,IAAIR,MAAM,IAAIF,gBAAgB,CAACW,QAAQ,CAACP,IAAI,CAAC;IAC/E,MAAMQ,KAAK,GAAG,CAACV,MAAM,IAAIA,MAAM,KAAK,CAAC,IAAIQ,KAAK,IAAIV,gBAAgB,CAACW,QAAQ,CAACV,QAAQ,CAAC;IACrFO,KAAK,CAACrB,KAAK,GAAG0B,OAAO,CAACV,MAAM,KAAK,EAAE,GAAG3B,IAAI,GAAGA,IAAI,KAAK0B,MAAM,IAAI,CAACU,KAAK,CAAC,CAAC;IACxEJ,KAAK,CAACtB,MAAM,GAAG2B,OAAO,CAACV,MAAM,KAAK,EAAE,GAAGS,KAAK,GAAGA,KAAK,KAAKF,KAAK,IAAI,CAAClC,IAAI,CAAC,CAAC;IACzE,OAAOuB,EAAE,CAACK,IAAI,CAAC;EACjB;AACF;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASZ,SAASA,CAACsB,KAAK,EAAE/B,MAAM,EAAE;EAChC+B,KAAK,CAACC,MAAM,IAAIhC,MAAM;EACtB+B,KAAK,CAAC/B,MAAM,IAAIA,MAAM;EACtB+B,KAAK,CAACE,YAAY,IAAIjC,MAAM;AAC9B","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}