{"ast":null,"code":"/**\r\n * @import {\r\n *   Construct,\r\n *   Event,\r\n *   Resolver,\r\n *   State,\r\n *   TokenizeContext,\r\n *   Tokenizer,\r\n *   Token\r\n * } from 'micromark-util-types'\r\n */\n\nimport { factoryDestination } from 'micromark-factory-destination';\nimport { factoryLabel } from 'micromark-factory-label';\nimport { factoryTitle } from 'micromark-factory-title';\nimport { factoryWhitespace } from 'micromark-factory-whitespace';\nimport { markdownLineEndingOrSpace } from 'micromark-util-character';\nimport { push, splice } from 'micromark-util-chunked';\nimport { normalizeIdentifier } from 'micromark-util-normalize-identifier';\nimport { resolveAll } from 'micromark-util-resolve-all';\n/** @type {Construct} */\nexport const labelEnd = {\n  name: 'labelEnd',\n  resolveAll: resolveAllLabelEnd,\n  resolveTo: resolveToLabelEnd,\n  tokenize: tokenizeLabelEnd\n};\n\n/** @type {Construct} */\nconst resourceConstruct = {\n  tokenize: tokenizeResource\n};\n/** @type {Construct} */\nconst referenceFullConstruct = {\n  tokenize: tokenizeReferenceFull\n};\n/** @type {Construct} */\nconst referenceCollapsedConstruct = {\n  tokenize: tokenizeReferenceCollapsed\n};\n\n/** @type {Resolver} */\nfunction resolveAllLabelEnd(events) {\n  let index = -1;\n  /** @type {Array<Event>} */\n  const newEvents = [];\n  while (++index < events.length) {\n    const token = events[index][1];\n    newEvents.push(events[index]);\n    if (token.type === \"labelImage\" || token.type === \"labelLink\" || token.type === \"labelEnd\") {\n      // Remove the marker.\n      const offset = token.type === \"labelImage\" ? 4 : 2;\n      token.type = \"data\";\n      index += offset;\n    }\n  }\n\n  // If the events are equal, we don't have to copy newEvents to events\n  if (events.length !== newEvents.length) {\n    splice(events, 0, events.length, newEvents);\n  }\n  return events;\n}\n\n/** @type {Resolver} */\nfunction resolveToLabelEnd(events, context) {\n  let index = events.length;\n  let offset = 0;\n  /** @type {Token} */\n  let token;\n  /** @type {number | undefined} */\n  let open;\n  /** @type {number | undefined} */\n  let close;\n  /** @type {Array<Event>} */\n  let media;\n\n  // Find an opening.\n  while (index--) {\n    token = events[index][1];\n    if (open) {\n      // If we see another link, or inactive link label, we‚Äôve been here before.\n      if (token.type === \"link\" || token.type === \"labelLink\" && token._inactive) {\n        break;\n      }\n\n      // Mark other link openings as inactive, as we can‚Äôt have links in\n      // links.\n      if (events[index][0] === 'enter' && token.type === \"labelLink\") {\n        token._inactive = true;\n      }\n    } else if (close) {\n      if (events[index][0] === 'enter' && (token.type === \"labelImage\" || token.type === \"labelLink\") && !token._balanced) {\n        open = index;\n        if (token.type !== \"labelLink\") {\n          offset = 2;\n          break;\n        }\n      }\n    } else if (token.type === \"labelEnd\") {\n      close = index;\n    }\n  }\n  const group = {\n    type: events[open][1].type === \"labelLink\" ? \"link\" : \"image\",\n    start: {\n      ...events[open][1].start\n    },\n    end: {\n      ...events[events.length - 1][1].end\n    }\n  };\n  const label = {\n    type: \"label\",\n    start: {\n      ...events[open][1].start\n    },\n    end: {\n      ...events[close][1].end\n    }\n  };\n  const text = {\n    type: \"labelText\",\n    start: {\n      ...events[open + offset + 2][1].end\n    },\n    end: {\n      ...events[close - 2][1].start\n    }\n  };\n  media = [['enter', group, context], ['enter', label, context]];\n\n  // Opening marker.\n  media = push(media, events.slice(open + 1, open + offset + 3));\n\n  // Text open.\n  media = push(media, [['enter', text, context]]);\n\n  // Always populated by defaults.\n\n  // Between.\n  media = push(media, resolveAll(context.parser.constructs.insideSpan.null, events.slice(open + offset + 4, close - 3), context));\n\n  // Text close, marker close, label close.\n  media = push(media, [['exit', text, context], events[close - 2], events[close - 1], ['exit', label, context]]);\n\n  // Reference, resource, or so.\n  media = push(media, events.slice(close + 1));\n\n  // Media close.\n  media = push(media, [['exit', group, context]]);\n  splice(events, open, events.length, media);\n  return events;\n}\n\n/**\r\n * @this {TokenizeContext}\r\n *   Context.\r\n * @type {Tokenizer}\r\n */\nfunction tokenizeLabelEnd(effects, ok, nok) {\n  const self = this;\n  let index = self.events.length;\n  /** @type {Token} */\n  let labelStart;\n  /** @type {boolean} */\n  let defined;\n\n  // Find an opening.\n  while (index--) {\n    if ((self.events[index][1].type === \"labelImage\" || self.events[index][1].type === \"labelLink\") && !self.events[index][1]._balanced) {\n      labelStart = self.events[index][1];\n      break;\n    }\n  }\n  return start;\n\n  /**\r\n   * Start of label end.\r\n   *\r\n   * ```markdown\r\n   * > | [a](b) c\r\n   *       ^\r\n   * > | [a][b] c\r\n   *       ^\r\n   * > | [a][] b\r\n   *       ^\r\n   * > | [a] b\r\n   * ```\r\n   *\r\n   * @type {State}\r\n   */\n  function start(code) {\n    // If there is not an okay opening.\n    if (!labelStart) {\n      return nok(code);\n    }\n\n    // If the corresponding label (link) start is marked as inactive,\n    // it means we‚Äôd be wrapping a link, like this:\n    //\n    // ```markdown\n    // > | a [b [c](d) e](f) g.\n    //                  ^\n    // ```\n    //\n    // We can‚Äôt have that, so it‚Äôs just balanced brackets.\n    if (labelStart._inactive) {\n      return labelEndNok(code);\n    }\n    defined = self.parser.defined.includes(normalizeIdentifier(self.sliceSerialize({\n      start: labelStart.end,\n      end: self.now()\n    })));\n    effects.enter(\"labelEnd\");\n    effects.enter(\"labelMarker\");\n    effects.consume(code);\n    effects.exit(\"labelMarker\");\n    effects.exit(\"labelEnd\");\n    return after;\n  }\n\n  /**\r\n   * After `]`.\r\n   *\r\n   * ```markdown\r\n   * > | [a](b) c\r\n   *       ^\r\n   * > | [a][b] c\r\n   *       ^\r\n   * > | [a][] b\r\n   *       ^\r\n   * > | [a] b\r\n   *       ^\r\n   * ```\r\n   *\r\n   * @type {State}\r\n   */\n  function after(code) {\n    // Note: `markdown-rs` also parses GFM footnotes here, which for us is in\n    // an extension.\n\n    // Resource (`[asd](fgh)`)?\n    if (code === 40) {\n      return effects.attempt(resourceConstruct, labelEndOk, defined ? labelEndOk : labelEndNok)(code);\n    }\n\n    // Full (`[asd][fgh]`) or collapsed (`[asd][]`) reference?\n    if (code === 91) {\n      return effects.attempt(referenceFullConstruct, labelEndOk, defined ? referenceNotFull : labelEndNok)(code);\n    }\n\n    // Shortcut (`[asd]`) reference?\n    return defined ? labelEndOk(code) : labelEndNok(code);\n  }\n\n  /**\r\n   * After `]`, at `[`, but not at a full reference.\r\n   *\r\n   * > üëâ **Note**: we only get here if the label is defined.\r\n   *\r\n   * ```markdown\r\n   * > | [a][] b\r\n   *        ^\r\n   * > | [a] b\r\n   *        ^\r\n   * ```\r\n   *\r\n   * @type {State}\r\n   */\n  function referenceNotFull(code) {\n    return effects.attempt(referenceCollapsedConstruct, labelEndOk, labelEndNok)(code);\n  }\n\n  /**\r\n   * Done, we found something.\r\n   *\r\n   * ```markdown\r\n   * > | [a](b) c\r\n   *           ^\r\n   * > | [a][b] c\r\n   *           ^\r\n   * > | [a][] b\r\n   *          ^\r\n   * > | [a] b\r\n   *        ^\r\n   * ```\r\n   *\r\n   * @type {State}\r\n   */\n  function labelEndOk(code) {\n    // Note: `markdown-rs` does a bunch of stuff here.\n    return ok(code);\n  }\n\n  /**\r\n   * Done, it‚Äôs nothing.\r\n   *\r\n   * There was an okay opening, but we didn‚Äôt match anything.\r\n   *\r\n   * ```markdown\r\n   * > | [a](b c\r\n   *        ^\r\n   * > | [a][b c\r\n   *        ^\r\n   * > | [a] b\r\n   *        ^\r\n   * ```\r\n   *\r\n   * @type {State}\r\n   */\n  function labelEndNok(code) {\n    labelStart._balanced = true;\n    return nok(code);\n  }\n}\n\n/**\r\n * @this {TokenizeContext}\r\n *   Context.\r\n * @type {Tokenizer}\r\n */\nfunction tokenizeResource(effects, ok, nok) {\n  return resourceStart;\n\n  /**\r\n   * At a resource.\r\n   *\r\n   * ```markdown\r\n   * > | [a](b) c\r\n   *        ^\r\n   * ```\r\n   *\r\n   * @type {State}\r\n   */\n  function resourceStart(code) {\n    effects.enter(\"resource\");\n    effects.enter(\"resourceMarker\");\n    effects.consume(code);\n    effects.exit(\"resourceMarker\");\n    return resourceBefore;\n  }\n\n  /**\r\n   * In resource, after `(`, at optional whitespace.\r\n   *\r\n   * ```markdown\r\n   * > | [a](b) c\r\n   *         ^\r\n   * ```\r\n   *\r\n   * @type {State}\r\n   */\n  function resourceBefore(code) {\n    return markdownLineEndingOrSpace(code) ? factoryWhitespace(effects, resourceOpen)(code) : resourceOpen(code);\n  }\n\n  /**\r\n   * In resource, after optional whitespace, at `)` or a destination.\r\n   *\r\n   * ```markdown\r\n   * > | [a](b) c\r\n   *         ^\r\n   * ```\r\n   *\r\n   * @type {State}\r\n   */\n  function resourceOpen(code) {\n    if (code === 41) {\n      return resourceEnd(code);\n    }\n    return factoryDestination(effects, resourceDestinationAfter, resourceDestinationMissing, \"resourceDestination\", \"resourceDestinationLiteral\", \"resourceDestinationLiteralMarker\", \"resourceDestinationRaw\", \"resourceDestinationString\", 32)(code);\n  }\n\n  /**\r\n   * In resource, after destination, at optional whitespace.\r\n   *\r\n   * ```markdown\r\n   * > | [a](b) c\r\n   *          ^\r\n   * ```\r\n   *\r\n   * @type {State}\r\n   */\n  function resourceDestinationAfter(code) {\n    return markdownLineEndingOrSpace(code) ? factoryWhitespace(effects, resourceBetween)(code) : resourceEnd(code);\n  }\n\n  /**\r\n   * At invalid destination.\r\n   *\r\n   * ```markdown\r\n   * > | [a](<<) b\r\n   *         ^\r\n   * ```\r\n   *\r\n   * @type {State}\r\n   */\n  function resourceDestinationMissing(code) {\n    return nok(code);\n  }\n\n  /**\r\n   * In resource, after destination and whitespace, at `(` or title.\r\n   *\r\n   * ```markdown\r\n   * > | [a](b ) c\r\n   *           ^\r\n   * ```\r\n   *\r\n   * @type {State}\r\n   */\n  function resourceBetween(code) {\n    if (code === 34 || code === 39 || code === 40) {\n      return factoryTitle(effects, resourceTitleAfter, nok, \"resourceTitle\", \"resourceTitleMarker\", \"resourceTitleString\")(code);\n    }\n    return resourceEnd(code);\n  }\n\n  /**\r\n   * In resource, after title, at optional whitespace.\r\n   *\r\n   * ```markdown\r\n   * > | [a](b \"c\") d\r\n   *              ^\r\n   * ```\r\n   *\r\n   * @type {State}\r\n   */\n  function resourceTitleAfter(code) {\n    return markdownLineEndingOrSpace(code) ? factoryWhitespace(effects, resourceEnd)(code) : resourceEnd(code);\n  }\n\n  /**\r\n   * In resource, at `)`.\r\n   *\r\n   * ```markdown\r\n   * > | [a](b) d\r\n   *          ^\r\n   * ```\r\n   *\r\n   * @type {State}\r\n   */\n  function resourceEnd(code) {\n    if (code === 41) {\n      effects.enter(\"resourceMarker\");\n      effects.consume(code);\n      effects.exit(\"resourceMarker\");\n      effects.exit(\"resource\");\n      return ok;\n    }\n    return nok(code);\n  }\n}\n\n/**\r\n * @this {TokenizeContext}\r\n *   Context.\r\n * @type {Tokenizer}\r\n */\nfunction tokenizeReferenceFull(effects, ok, nok) {\n  const self = this;\n  return referenceFull;\n\n  /**\r\n   * In a reference (full), at the `[`.\r\n   *\r\n   * ```markdown\r\n   * > | [a][b] d\r\n   *        ^\r\n   * ```\r\n   *\r\n   * @type {State}\r\n   */\n  function referenceFull(code) {\n    return factoryLabel.call(self, effects, referenceFullAfter, referenceFullMissing, \"reference\", \"referenceMarker\", \"referenceString\")(code);\n  }\n\n  /**\r\n   * In a reference (full), after `]`.\r\n   *\r\n   * ```markdown\r\n   * > | [a][b] d\r\n   *          ^\r\n   * ```\r\n   *\r\n   * @type {State}\r\n   */\n  function referenceFullAfter(code) {\n    return self.parser.defined.includes(normalizeIdentifier(self.sliceSerialize(self.events[self.events.length - 1][1]).slice(1, -1))) ? ok(code) : nok(code);\n  }\n\n  /**\r\n   * In reference (full) that was missing.\r\n   *\r\n   * ```markdown\r\n   * > | [a][b d\r\n   *        ^\r\n   * ```\r\n   *\r\n   * @type {State}\r\n   */\n  function referenceFullMissing(code) {\n    return nok(code);\n  }\n}\n\n/**\r\n * @this {TokenizeContext}\r\n *   Context.\r\n * @type {Tokenizer}\r\n */\nfunction tokenizeReferenceCollapsed(effects, ok, nok) {\n  return referenceCollapsedStart;\n\n  /**\r\n   * In reference (collapsed), at `[`.\r\n   *\r\n   * > üëâ **Note**: we only get here if the label is defined.\r\n   *\r\n   * ```markdown\r\n   * > | [a][] d\r\n   *        ^\r\n   * ```\r\n   *\r\n   * @type {State}\r\n   */\n  function referenceCollapsedStart(code) {\n    // We only attempt a collapsed label if there‚Äôs a `[`.\n\n    effects.enter(\"reference\");\n    effects.enter(\"referenceMarker\");\n    effects.consume(code);\n    effects.exit(\"referenceMarker\");\n    return referenceCollapsedOpen;\n  }\n\n  /**\r\n   * In reference (collapsed), at `]`.\r\n   *\r\n   * > üëâ **Note**: we only get here if the label is defined.\r\n   *\r\n   * ```markdown\r\n   * > | [a][] d\r\n   *         ^\r\n   * ```\r\n   *\r\n   *  @type {State}\r\n   */\n  function referenceCollapsedOpen(code) {\n    if (code === 93) {\n      effects.enter(\"referenceMarker\");\n      effects.consume(code);\n      effects.exit(\"referenceMarker\");\n      effects.exit(\"reference\");\n      return ok;\n    }\n    return nok(code);\n  }\n}","map":{"version":3,"names":["factoryDestination","factoryLabel","factoryTitle","factoryWhitespace","markdownLineEndingOrSpace","push","splice","normalizeIdentifier","resolveAll","labelEnd","name","resolveAllLabelEnd","resolveTo","resolveToLabelEnd","tokenize","tokenizeLabelEnd","resourceConstruct","tokenizeResource","referenceFullConstruct","tokenizeReferenceFull","referenceCollapsedConstruct","tokenizeReferenceCollapsed","events","index","newEvents","length","token","type","offset","context","open","close","media","_inactive","_balanced","group","start","end","label","text","slice","parser","constructs","insideSpan","null","effects","ok","nok","self","labelStart","defined","code","labelEndNok","includes","sliceSerialize","now","enter","consume","exit","after","attempt","labelEndOk","referenceNotFull","resourceStart","resourceBefore","resourceOpen","resourceEnd","resourceDestinationAfter","resourceDestinationMissing","resourceBetween","resourceTitleAfter","referenceFull","call","referenceFullAfter","referenceFullMissing","referenceCollapsedStart","referenceCollapsedOpen"],"sources":["C:/Users/LENOVO/OneDrive/Masa√ºst√º/Bitirme/bitirme/frontend/doc-manager-ui/node_modules/micromark-core-commonmark/lib/label-end.js"],"sourcesContent":["/**\r\n * @import {\r\n *   Construct,\r\n *   Event,\r\n *   Resolver,\r\n *   State,\r\n *   TokenizeContext,\r\n *   Tokenizer,\r\n *   Token\r\n * } from 'micromark-util-types'\r\n */\r\n\r\nimport { factoryDestination } from 'micromark-factory-destination';\r\nimport { factoryLabel } from 'micromark-factory-label';\r\nimport { factoryTitle } from 'micromark-factory-title';\r\nimport { factoryWhitespace } from 'micromark-factory-whitespace';\r\nimport { markdownLineEndingOrSpace } from 'micromark-util-character';\r\nimport { push, splice } from 'micromark-util-chunked';\r\nimport { normalizeIdentifier } from 'micromark-util-normalize-identifier';\r\nimport { resolveAll } from 'micromark-util-resolve-all';\r\n/** @type {Construct} */\r\nexport const labelEnd = {\r\n  name: 'labelEnd',\r\n  resolveAll: resolveAllLabelEnd,\r\n  resolveTo: resolveToLabelEnd,\r\n  tokenize: tokenizeLabelEnd\r\n};\r\n\r\n/** @type {Construct} */\r\nconst resourceConstruct = {\r\n  tokenize: tokenizeResource\r\n};\r\n/** @type {Construct} */\r\nconst referenceFullConstruct = {\r\n  tokenize: tokenizeReferenceFull\r\n};\r\n/** @type {Construct} */\r\nconst referenceCollapsedConstruct = {\r\n  tokenize: tokenizeReferenceCollapsed\r\n};\r\n\r\n/** @type {Resolver} */\r\nfunction resolveAllLabelEnd(events) {\r\n  let index = -1;\r\n  /** @type {Array<Event>} */\r\n  const newEvents = [];\r\n  while (++index < events.length) {\r\n    const token = events[index][1];\r\n    newEvents.push(events[index]);\r\n    if (token.type === \"labelImage\" || token.type === \"labelLink\" || token.type === \"labelEnd\") {\r\n      // Remove the marker.\r\n      const offset = token.type === \"labelImage\" ? 4 : 2;\r\n      token.type = \"data\";\r\n      index += offset;\r\n    }\r\n  }\r\n\r\n  // If the events are equal, we don't have to copy newEvents to events\r\n  if (events.length !== newEvents.length) {\r\n    splice(events, 0, events.length, newEvents);\r\n  }\r\n  return events;\r\n}\r\n\r\n/** @type {Resolver} */\r\nfunction resolveToLabelEnd(events, context) {\r\n  let index = events.length;\r\n  let offset = 0;\r\n  /** @type {Token} */\r\n  let token;\r\n  /** @type {number | undefined} */\r\n  let open;\r\n  /** @type {number | undefined} */\r\n  let close;\r\n  /** @type {Array<Event>} */\r\n  let media;\r\n\r\n  // Find an opening.\r\n  while (index--) {\r\n    token = events[index][1];\r\n    if (open) {\r\n      // If we see another link, or inactive link label, we‚Äôve been here before.\r\n      if (token.type === \"link\" || token.type === \"labelLink\" && token._inactive) {\r\n        break;\r\n      }\r\n\r\n      // Mark other link openings as inactive, as we can‚Äôt have links in\r\n      // links.\r\n      if (events[index][0] === 'enter' && token.type === \"labelLink\") {\r\n        token._inactive = true;\r\n      }\r\n    } else if (close) {\r\n      if (events[index][0] === 'enter' && (token.type === \"labelImage\" || token.type === \"labelLink\") && !token._balanced) {\r\n        open = index;\r\n        if (token.type !== \"labelLink\") {\r\n          offset = 2;\r\n          break;\r\n        }\r\n      }\r\n    } else if (token.type === \"labelEnd\") {\r\n      close = index;\r\n    }\r\n  }\r\n  const group = {\r\n    type: events[open][1].type === \"labelLink\" ? \"link\" : \"image\",\r\n    start: {\r\n      ...events[open][1].start\r\n    },\r\n    end: {\r\n      ...events[events.length - 1][1].end\r\n    }\r\n  };\r\n  const label = {\r\n    type: \"label\",\r\n    start: {\r\n      ...events[open][1].start\r\n    },\r\n    end: {\r\n      ...events[close][1].end\r\n    }\r\n  };\r\n  const text = {\r\n    type: \"labelText\",\r\n    start: {\r\n      ...events[open + offset + 2][1].end\r\n    },\r\n    end: {\r\n      ...events[close - 2][1].start\r\n    }\r\n  };\r\n  media = [['enter', group, context], ['enter', label, context]];\r\n\r\n  // Opening marker.\r\n  media = push(media, events.slice(open + 1, open + offset + 3));\r\n\r\n  // Text open.\r\n  media = push(media, [['enter', text, context]]);\r\n\r\n  // Always populated by defaults.\r\n\r\n  // Between.\r\n  media = push(media, resolveAll(context.parser.constructs.insideSpan.null, events.slice(open + offset + 4, close - 3), context));\r\n\r\n  // Text close, marker close, label close.\r\n  media = push(media, [['exit', text, context], events[close - 2], events[close - 1], ['exit', label, context]]);\r\n\r\n  // Reference, resource, or so.\r\n  media = push(media, events.slice(close + 1));\r\n\r\n  // Media close.\r\n  media = push(media, [['exit', group, context]]);\r\n  splice(events, open, events.length, media);\r\n  return events;\r\n}\r\n\r\n/**\r\n * @this {TokenizeContext}\r\n *   Context.\r\n * @type {Tokenizer}\r\n */\r\nfunction tokenizeLabelEnd(effects, ok, nok) {\r\n  const self = this;\r\n  let index = self.events.length;\r\n  /** @type {Token} */\r\n  let labelStart;\r\n  /** @type {boolean} */\r\n  let defined;\r\n\r\n  // Find an opening.\r\n  while (index--) {\r\n    if ((self.events[index][1].type === \"labelImage\" || self.events[index][1].type === \"labelLink\") && !self.events[index][1]._balanced) {\r\n      labelStart = self.events[index][1];\r\n      break;\r\n    }\r\n  }\r\n  return start;\r\n\r\n  /**\r\n   * Start of label end.\r\n   *\r\n   * ```markdown\r\n   * > | [a](b) c\r\n   *       ^\r\n   * > | [a][b] c\r\n   *       ^\r\n   * > | [a][] b\r\n   *       ^\r\n   * > | [a] b\r\n   * ```\r\n   *\r\n   * @type {State}\r\n   */\r\n  function start(code) {\r\n    // If there is not an okay opening.\r\n    if (!labelStart) {\r\n      return nok(code);\r\n    }\r\n\r\n    // If the corresponding label (link) start is marked as inactive,\r\n    // it means we‚Äôd be wrapping a link, like this:\r\n    //\r\n    // ```markdown\r\n    // > | a [b [c](d) e](f) g.\r\n    //                  ^\r\n    // ```\r\n    //\r\n    // We can‚Äôt have that, so it‚Äôs just balanced brackets.\r\n    if (labelStart._inactive) {\r\n      return labelEndNok(code);\r\n    }\r\n    defined = self.parser.defined.includes(normalizeIdentifier(self.sliceSerialize({\r\n      start: labelStart.end,\r\n      end: self.now()\r\n    })));\r\n    effects.enter(\"labelEnd\");\r\n    effects.enter(\"labelMarker\");\r\n    effects.consume(code);\r\n    effects.exit(\"labelMarker\");\r\n    effects.exit(\"labelEnd\");\r\n    return after;\r\n  }\r\n\r\n  /**\r\n   * After `]`.\r\n   *\r\n   * ```markdown\r\n   * > | [a](b) c\r\n   *       ^\r\n   * > | [a][b] c\r\n   *       ^\r\n   * > | [a][] b\r\n   *       ^\r\n   * > | [a] b\r\n   *       ^\r\n   * ```\r\n   *\r\n   * @type {State}\r\n   */\r\n  function after(code) {\r\n    // Note: `markdown-rs` also parses GFM footnotes here, which for us is in\r\n    // an extension.\r\n\r\n    // Resource (`[asd](fgh)`)?\r\n    if (code === 40) {\r\n      return effects.attempt(resourceConstruct, labelEndOk, defined ? labelEndOk : labelEndNok)(code);\r\n    }\r\n\r\n    // Full (`[asd][fgh]`) or collapsed (`[asd][]`) reference?\r\n    if (code === 91) {\r\n      return effects.attempt(referenceFullConstruct, labelEndOk, defined ? referenceNotFull : labelEndNok)(code);\r\n    }\r\n\r\n    // Shortcut (`[asd]`) reference?\r\n    return defined ? labelEndOk(code) : labelEndNok(code);\r\n  }\r\n\r\n  /**\r\n   * After `]`, at `[`, but not at a full reference.\r\n   *\r\n   * > üëâ **Note**: we only get here if the label is defined.\r\n   *\r\n   * ```markdown\r\n   * > | [a][] b\r\n   *        ^\r\n   * > | [a] b\r\n   *        ^\r\n   * ```\r\n   *\r\n   * @type {State}\r\n   */\r\n  function referenceNotFull(code) {\r\n    return effects.attempt(referenceCollapsedConstruct, labelEndOk, labelEndNok)(code);\r\n  }\r\n\r\n  /**\r\n   * Done, we found something.\r\n   *\r\n   * ```markdown\r\n   * > | [a](b) c\r\n   *           ^\r\n   * > | [a][b] c\r\n   *           ^\r\n   * > | [a][] b\r\n   *          ^\r\n   * > | [a] b\r\n   *        ^\r\n   * ```\r\n   *\r\n   * @type {State}\r\n   */\r\n  function labelEndOk(code) {\r\n    // Note: `markdown-rs` does a bunch of stuff here.\r\n    return ok(code);\r\n  }\r\n\r\n  /**\r\n   * Done, it‚Äôs nothing.\r\n   *\r\n   * There was an okay opening, but we didn‚Äôt match anything.\r\n   *\r\n   * ```markdown\r\n   * > | [a](b c\r\n   *        ^\r\n   * > | [a][b c\r\n   *        ^\r\n   * > | [a] b\r\n   *        ^\r\n   * ```\r\n   *\r\n   * @type {State}\r\n   */\r\n  function labelEndNok(code) {\r\n    labelStart._balanced = true;\r\n    return nok(code);\r\n  }\r\n}\r\n\r\n/**\r\n * @this {TokenizeContext}\r\n *   Context.\r\n * @type {Tokenizer}\r\n */\r\nfunction tokenizeResource(effects, ok, nok) {\r\n  return resourceStart;\r\n\r\n  /**\r\n   * At a resource.\r\n   *\r\n   * ```markdown\r\n   * > | [a](b) c\r\n   *        ^\r\n   * ```\r\n   *\r\n   * @type {State}\r\n   */\r\n  function resourceStart(code) {\r\n    effects.enter(\"resource\");\r\n    effects.enter(\"resourceMarker\");\r\n    effects.consume(code);\r\n    effects.exit(\"resourceMarker\");\r\n    return resourceBefore;\r\n  }\r\n\r\n  /**\r\n   * In resource, after `(`, at optional whitespace.\r\n   *\r\n   * ```markdown\r\n   * > | [a](b) c\r\n   *         ^\r\n   * ```\r\n   *\r\n   * @type {State}\r\n   */\r\n  function resourceBefore(code) {\r\n    return markdownLineEndingOrSpace(code) ? factoryWhitespace(effects, resourceOpen)(code) : resourceOpen(code);\r\n  }\r\n\r\n  /**\r\n   * In resource, after optional whitespace, at `)` or a destination.\r\n   *\r\n   * ```markdown\r\n   * > | [a](b) c\r\n   *         ^\r\n   * ```\r\n   *\r\n   * @type {State}\r\n   */\r\n  function resourceOpen(code) {\r\n    if (code === 41) {\r\n      return resourceEnd(code);\r\n    }\r\n    return factoryDestination(effects, resourceDestinationAfter, resourceDestinationMissing, \"resourceDestination\", \"resourceDestinationLiteral\", \"resourceDestinationLiteralMarker\", \"resourceDestinationRaw\", \"resourceDestinationString\", 32)(code);\r\n  }\r\n\r\n  /**\r\n   * In resource, after destination, at optional whitespace.\r\n   *\r\n   * ```markdown\r\n   * > | [a](b) c\r\n   *          ^\r\n   * ```\r\n   *\r\n   * @type {State}\r\n   */\r\n  function resourceDestinationAfter(code) {\r\n    return markdownLineEndingOrSpace(code) ? factoryWhitespace(effects, resourceBetween)(code) : resourceEnd(code);\r\n  }\r\n\r\n  /**\r\n   * At invalid destination.\r\n   *\r\n   * ```markdown\r\n   * > | [a](<<) b\r\n   *         ^\r\n   * ```\r\n   *\r\n   * @type {State}\r\n   */\r\n  function resourceDestinationMissing(code) {\r\n    return nok(code);\r\n  }\r\n\r\n  /**\r\n   * In resource, after destination and whitespace, at `(` or title.\r\n   *\r\n   * ```markdown\r\n   * > | [a](b ) c\r\n   *           ^\r\n   * ```\r\n   *\r\n   * @type {State}\r\n   */\r\n  function resourceBetween(code) {\r\n    if (code === 34 || code === 39 || code === 40) {\r\n      return factoryTitle(effects, resourceTitleAfter, nok, \"resourceTitle\", \"resourceTitleMarker\", \"resourceTitleString\")(code);\r\n    }\r\n    return resourceEnd(code);\r\n  }\r\n\r\n  /**\r\n   * In resource, after title, at optional whitespace.\r\n   *\r\n   * ```markdown\r\n   * > | [a](b \"c\") d\r\n   *              ^\r\n   * ```\r\n   *\r\n   * @type {State}\r\n   */\r\n  function resourceTitleAfter(code) {\r\n    return markdownLineEndingOrSpace(code) ? factoryWhitespace(effects, resourceEnd)(code) : resourceEnd(code);\r\n  }\r\n\r\n  /**\r\n   * In resource, at `)`.\r\n   *\r\n   * ```markdown\r\n   * > | [a](b) d\r\n   *          ^\r\n   * ```\r\n   *\r\n   * @type {State}\r\n   */\r\n  function resourceEnd(code) {\r\n    if (code === 41) {\r\n      effects.enter(\"resourceMarker\");\r\n      effects.consume(code);\r\n      effects.exit(\"resourceMarker\");\r\n      effects.exit(\"resource\");\r\n      return ok;\r\n    }\r\n    return nok(code);\r\n  }\r\n}\r\n\r\n/**\r\n * @this {TokenizeContext}\r\n *   Context.\r\n * @type {Tokenizer}\r\n */\r\nfunction tokenizeReferenceFull(effects, ok, nok) {\r\n  const self = this;\r\n  return referenceFull;\r\n\r\n  /**\r\n   * In a reference (full), at the `[`.\r\n   *\r\n   * ```markdown\r\n   * > | [a][b] d\r\n   *        ^\r\n   * ```\r\n   *\r\n   * @type {State}\r\n   */\r\n  function referenceFull(code) {\r\n    return factoryLabel.call(self, effects, referenceFullAfter, referenceFullMissing, \"reference\", \"referenceMarker\", \"referenceString\")(code);\r\n  }\r\n\r\n  /**\r\n   * In a reference (full), after `]`.\r\n   *\r\n   * ```markdown\r\n   * > | [a][b] d\r\n   *          ^\r\n   * ```\r\n   *\r\n   * @type {State}\r\n   */\r\n  function referenceFullAfter(code) {\r\n    return self.parser.defined.includes(normalizeIdentifier(self.sliceSerialize(self.events[self.events.length - 1][1]).slice(1, -1))) ? ok(code) : nok(code);\r\n  }\r\n\r\n  /**\r\n   * In reference (full) that was missing.\r\n   *\r\n   * ```markdown\r\n   * > | [a][b d\r\n   *        ^\r\n   * ```\r\n   *\r\n   * @type {State}\r\n   */\r\n  function referenceFullMissing(code) {\r\n    return nok(code);\r\n  }\r\n}\r\n\r\n/**\r\n * @this {TokenizeContext}\r\n *   Context.\r\n * @type {Tokenizer}\r\n */\r\nfunction tokenizeReferenceCollapsed(effects, ok, nok) {\r\n  return referenceCollapsedStart;\r\n\r\n  /**\r\n   * In reference (collapsed), at `[`.\r\n   *\r\n   * > üëâ **Note**: we only get here if the label is defined.\r\n   *\r\n   * ```markdown\r\n   * > | [a][] d\r\n   *        ^\r\n   * ```\r\n   *\r\n   * @type {State}\r\n   */\r\n  function referenceCollapsedStart(code) {\r\n    // We only attempt a collapsed label if there‚Äôs a `[`.\r\n\r\n    effects.enter(\"reference\");\r\n    effects.enter(\"referenceMarker\");\r\n    effects.consume(code);\r\n    effects.exit(\"referenceMarker\");\r\n    return referenceCollapsedOpen;\r\n  }\r\n\r\n  /**\r\n   * In reference (collapsed), at `]`.\r\n   *\r\n   * > üëâ **Note**: we only get here if the label is defined.\r\n   *\r\n   * ```markdown\r\n   * > | [a][] d\r\n   *         ^\r\n   * ```\r\n   *\r\n   *  @type {State}\r\n   */\r\n  function referenceCollapsedOpen(code) {\r\n    if (code === 93) {\r\n      effects.enter(\"referenceMarker\");\r\n      effects.consume(code);\r\n      effects.exit(\"referenceMarker\");\r\n      effects.exit(\"reference\");\r\n      return ok;\r\n    }\r\n    return nok(code);\r\n  }\r\n}"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,SAASA,kBAAkB,QAAQ,+BAA+B;AAClE,SAASC,YAAY,QAAQ,yBAAyB;AACtD,SAASC,YAAY,QAAQ,yBAAyB;AACtD,SAASC,iBAAiB,QAAQ,8BAA8B;AAChE,SAASC,yBAAyB,QAAQ,0BAA0B;AACpE,SAASC,IAAI,EAAEC,MAAM,QAAQ,wBAAwB;AACrD,SAASC,mBAAmB,QAAQ,qCAAqC;AACzE,SAASC,UAAU,QAAQ,4BAA4B;AACvD;AACA,OAAO,MAAMC,QAAQ,GAAG;EACtBC,IAAI,EAAE,UAAU;EAChBF,UAAU,EAAEG,kBAAkB;EAC9BC,SAAS,EAAEC,iBAAiB;EAC5BC,QAAQ,EAAEC;AACZ,CAAC;;AAED;AACA,MAAMC,iBAAiB,GAAG;EACxBF,QAAQ,EAAEG;AACZ,CAAC;AACD;AACA,MAAMC,sBAAsB,GAAG;EAC7BJ,QAAQ,EAAEK;AACZ,CAAC;AACD;AACA,MAAMC,2BAA2B,GAAG;EAClCN,QAAQ,EAAEO;AACZ,CAAC;;AAED;AACA,SAASV,kBAAkBA,CAACW,MAAM,EAAE;EAClC,IAAIC,KAAK,GAAG,CAAC,CAAC;EACd;EACA,MAAMC,SAAS,GAAG,EAAE;EACpB,OAAO,EAAED,KAAK,GAAGD,MAAM,CAACG,MAAM,EAAE;IAC9B,MAAMC,KAAK,GAAGJ,MAAM,CAACC,KAAK,CAAC,CAAC,CAAC,CAAC;IAC9BC,SAAS,CAACnB,IAAI,CAACiB,MAAM,CAACC,KAAK,CAAC,CAAC;IAC7B,IAAIG,KAAK,CAACC,IAAI,KAAK,YAAY,IAAID,KAAK,CAACC,IAAI,KAAK,WAAW,IAAID,KAAK,CAACC,IAAI,KAAK,UAAU,EAAE;MAC1F;MACA,MAAMC,MAAM,GAAGF,KAAK,CAACC,IAAI,KAAK,YAAY,GAAG,CAAC,GAAG,CAAC;MAClDD,KAAK,CAACC,IAAI,GAAG,MAAM;MACnBJ,KAAK,IAAIK,MAAM;IACjB;EACF;;EAEA;EACA,IAAIN,MAAM,CAACG,MAAM,KAAKD,SAAS,CAACC,MAAM,EAAE;IACtCnB,MAAM,CAACgB,MAAM,EAAE,CAAC,EAAEA,MAAM,CAACG,MAAM,EAAED,SAAS,CAAC;EAC7C;EACA,OAAOF,MAAM;AACf;;AAEA;AACA,SAAST,iBAAiBA,CAACS,MAAM,EAAEO,OAAO,EAAE;EAC1C,IAAIN,KAAK,GAAGD,MAAM,CAACG,MAAM;EACzB,IAAIG,MAAM,GAAG,CAAC;EACd;EACA,IAAIF,KAAK;EACT;EACA,IAAII,IAAI;EACR;EACA,IAAIC,KAAK;EACT;EACA,IAAIC,KAAK;;EAET;EACA,OAAOT,KAAK,EAAE,EAAE;IACdG,KAAK,GAAGJ,MAAM,CAACC,KAAK,CAAC,CAAC,CAAC,CAAC;IACxB,IAAIO,IAAI,EAAE;MACR;MACA,IAAIJ,KAAK,CAACC,IAAI,KAAK,MAAM,IAAID,KAAK,CAACC,IAAI,KAAK,WAAW,IAAID,KAAK,CAACO,SAAS,EAAE;QAC1E;MACF;;MAEA;MACA;MACA,IAAIX,MAAM,CAACC,KAAK,CAAC,CAAC,CAAC,CAAC,KAAK,OAAO,IAAIG,KAAK,CAACC,IAAI,KAAK,WAAW,EAAE;QAC9DD,KAAK,CAACO,SAAS,GAAG,IAAI;MACxB;IACF,CAAC,MAAM,IAAIF,KAAK,EAAE;MAChB,IAAIT,MAAM,CAACC,KAAK,CAAC,CAAC,CAAC,CAAC,KAAK,OAAO,KAAKG,KAAK,CAACC,IAAI,KAAK,YAAY,IAAID,KAAK,CAACC,IAAI,KAAK,WAAW,CAAC,IAAI,CAACD,KAAK,CAACQ,SAAS,EAAE;QACnHJ,IAAI,GAAGP,KAAK;QACZ,IAAIG,KAAK,CAACC,IAAI,KAAK,WAAW,EAAE;UAC9BC,MAAM,GAAG,CAAC;UACV;QACF;MACF;IACF,CAAC,MAAM,IAAIF,KAAK,CAACC,IAAI,KAAK,UAAU,EAAE;MACpCI,KAAK,GAAGR,KAAK;IACf;EACF;EACA,MAAMY,KAAK,GAAG;IACZR,IAAI,EAAEL,MAAM,CAACQ,IAAI,CAAC,CAAC,CAAC,CAAC,CAACH,IAAI,KAAK,WAAW,GAAG,MAAM,GAAG,OAAO;IAC7DS,KAAK,EAAE;MACL,GAAGd,MAAM,CAACQ,IAAI,CAAC,CAAC,CAAC,CAAC,CAACM;IACrB,CAAC;IACDC,GAAG,EAAE;MACH,GAAGf,MAAM,CAACA,MAAM,CAACG,MAAM,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,CAACY;IAClC;EACF,CAAC;EACD,MAAMC,KAAK,GAAG;IACZX,IAAI,EAAE,OAAO;IACbS,KAAK,EAAE;MACL,GAAGd,MAAM,CAACQ,IAAI,CAAC,CAAC,CAAC,CAAC,CAACM;IACrB,CAAC;IACDC,GAAG,EAAE;MACH,GAAGf,MAAM,CAACS,KAAK,CAAC,CAAC,CAAC,CAAC,CAACM;IACtB;EACF,CAAC;EACD,MAAME,IAAI,GAAG;IACXZ,IAAI,EAAE,WAAW;IACjBS,KAAK,EAAE;MACL,GAAGd,MAAM,CAACQ,IAAI,GAAGF,MAAM,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,CAACS;IAClC,CAAC;IACDA,GAAG,EAAE;MACH,GAAGf,MAAM,CAACS,KAAK,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,CAACK;IAC1B;EACF,CAAC;EACDJ,KAAK,GAAG,CAAC,CAAC,OAAO,EAAEG,KAAK,EAAEN,OAAO,CAAC,EAAE,CAAC,OAAO,EAAES,KAAK,EAAET,OAAO,CAAC,CAAC;;EAE9D;EACAG,KAAK,GAAG3B,IAAI,CAAC2B,KAAK,EAAEV,MAAM,CAACkB,KAAK,CAACV,IAAI,GAAG,CAAC,EAAEA,IAAI,GAAGF,MAAM,GAAG,CAAC,CAAC,CAAC;;EAE9D;EACAI,KAAK,GAAG3B,IAAI,CAAC2B,KAAK,EAAE,CAAC,CAAC,OAAO,EAAEO,IAAI,EAAEV,OAAO,CAAC,CAAC,CAAC;;EAE/C;;EAEA;EACAG,KAAK,GAAG3B,IAAI,CAAC2B,KAAK,EAAExB,UAAU,CAACqB,OAAO,CAACY,MAAM,CAACC,UAAU,CAACC,UAAU,CAACC,IAAI,EAAEtB,MAAM,CAACkB,KAAK,CAACV,IAAI,GAAGF,MAAM,GAAG,CAAC,EAAEG,KAAK,GAAG,CAAC,CAAC,EAAEF,OAAO,CAAC,CAAC;;EAE/H;EACAG,KAAK,GAAG3B,IAAI,CAAC2B,KAAK,EAAE,CAAC,CAAC,MAAM,EAAEO,IAAI,EAAEV,OAAO,CAAC,EAAEP,MAAM,CAACS,KAAK,GAAG,CAAC,CAAC,EAAET,MAAM,CAACS,KAAK,GAAG,CAAC,CAAC,EAAE,CAAC,MAAM,EAAEO,KAAK,EAAET,OAAO,CAAC,CAAC,CAAC;;EAE9G;EACAG,KAAK,GAAG3B,IAAI,CAAC2B,KAAK,EAAEV,MAAM,CAACkB,KAAK,CAACT,KAAK,GAAG,CAAC,CAAC,CAAC;;EAE5C;EACAC,KAAK,GAAG3B,IAAI,CAAC2B,KAAK,EAAE,CAAC,CAAC,MAAM,EAAEG,KAAK,EAAEN,OAAO,CAAC,CAAC,CAAC;EAC/CvB,MAAM,CAACgB,MAAM,EAAEQ,IAAI,EAAER,MAAM,CAACG,MAAM,EAAEO,KAAK,CAAC;EAC1C,OAAOV,MAAM;AACf;;AAEA;AACA;AACA;AACA;AACA;AACA,SAASP,gBAAgBA,CAAC8B,OAAO,EAAEC,EAAE,EAAEC,GAAG,EAAE;EAC1C,MAAMC,IAAI,GAAG,IAAI;EACjB,IAAIzB,KAAK,GAAGyB,IAAI,CAAC1B,MAAM,CAACG,MAAM;EAC9B;EACA,IAAIwB,UAAU;EACd;EACA,IAAIC,OAAO;;EAEX;EACA,OAAO3B,KAAK,EAAE,EAAE;IACd,IAAI,CAACyB,IAAI,CAAC1B,MAAM,CAACC,KAAK,CAAC,CAAC,CAAC,CAAC,CAACI,IAAI,KAAK,YAAY,IAAIqB,IAAI,CAAC1B,MAAM,CAACC,KAAK,CAAC,CAAC,CAAC,CAAC,CAACI,IAAI,KAAK,WAAW,KAAK,CAACqB,IAAI,CAAC1B,MAAM,CAACC,KAAK,CAAC,CAAC,CAAC,CAAC,CAACW,SAAS,EAAE;MACnIe,UAAU,GAAGD,IAAI,CAAC1B,MAAM,CAACC,KAAK,CAAC,CAAC,CAAC,CAAC;MAClC;IACF;EACF;EACA,OAAOa,KAAK;;EAEZ;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACE,SAASA,KAAKA,CAACe,IAAI,EAAE;IACnB;IACA,IAAI,CAACF,UAAU,EAAE;MACf,OAAOF,GAAG,CAACI,IAAI,CAAC;IAClB;;IAEA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA,IAAIF,UAAU,CAAChB,SAAS,EAAE;MACxB,OAAOmB,WAAW,CAACD,IAAI,CAAC;IAC1B;IACAD,OAAO,GAAGF,IAAI,CAACP,MAAM,CAACS,OAAO,CAACG,QAAQ,CAAC9C,mBAAmB,CAACyC,IAAI,CAACM,cAAc,CAAC;MAC7ElB,KAAK,EAAEa,UAAU,CAACZ,GAAG;MACrBA,GAAG,EAAEW,IAAI,CAACO,GAAG,CAAC;IAChB,CAAC,CAAC,CAAC,CAAC;IACJV,OAAO,CAACW,KAAK,CAAC,UAAU,CAAC;IACzBX,OAAO,CAACW,KAAK,CAAC,aAAa,CAAC;IAC5BX,OAAO,CAACY,OAAO,CAACN,IAAI,CAAC;IACrBN,OAAO,CAACa,IAAI,CAAC,aAAa,CAAC;IAC3Bb,OAAO,CAACa,IAAI,CAAC,UAAU,CAAC;IACxB,OAAOC,KAAK;EACd;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACE,SAASA,KAAKA,CAACR,IAAI,EAAE;IACnB;IACA;;IAEA;IACA,IAAIA,IAAI,KAAK,EAAE,EAAE;MACf,OAAON,OAAO,CAACe,OAAO,CAAC5C,iBAAiB,EAAE6C,UAAU,EAAEX,OAAO,GAAGW,UAAU,GAAGT,WAAW,CAAC,CAACD,IAAI,CAAC;IACjG;;IAEA;IACA,IAAIA,IAAI,KAAK,EAAE,EAAE;MACf,OAAON,OAAO,CAACe,OAAO,CAAC1C,sBAAsB,EAAE2C,UAAU,EAAEX,OAAO,GAAGY,gBAAgB,GAAGV,WAAW,CAAC,CAACD,IAAI,CAAC;IAC5G;;IAEA;IACA,OAAOD,OAAO,GAAGW,UAAU,CAACV,IAAI,CAAC,GAAGC,WAAW,CAACD,IAAI,CAAC;EACvD;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACE,SAASW,gBAAgBA,CAACX,IAAI,EAAE;IAC9B,OAAON,OAAO,CAACe,OAAO,CAACxC,2BAA2B,EAAEyC,UAAU,EAAET,WAAW,CAAC,CAACD,IAAI,CAAC;EACpF;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACE,SAASU,UAAUA,CAACV,IAAI,EAAE;IACxB;IACA,OAAOL,EAAE,CAACK,IAAI,CAAC;EACjB;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACE,SAASC,WAAWA,CAACD,IAAI,EAAE;IACzBF,UAAU,CAACf,SAAS,GAAG,IAAI;IAC3B,OAAOa,GAAG,CAACI,IAAI,CAAC;EAClB;AACF;;AAEA;AACA;AACA;AACA;AACA;AACA,SAASlC,gBAAgBA,CAAC4B,OAAO,EAAEC,EAAE,EAAEC,GAAG,EAAE;EAC1C,OAAOgB,aAAa;;EAEpB;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACE,SAASA,aAAaA,CAACZ,IAAI,EAAE;IAC3BN,OAAO,CAACW,KAAK,CAAC,UAAU,CAAC;IACzBX,OAAO,CAACW,KAAK,CAAC,gBAAgB,CAAC;IAC/BX,OAAO,CAACY,OAAO,CAACN,IAAI,CAAC;IACrBN,OAAO,CAACa,IAAI,CAAC,gBAAgB,CAAC;IAC9B,OAAOM,cAAc;EACvB;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACE,SAASA,cAAcA,CAACb,IAAI,EAAE;IAC5B,OAAO/C,yBAAyB,CAAC+C,IAAI,CAAC,GAAGhD,iBAAiB,CAAC0C,OAAO,EAAEoB,YAAY,CAAC,CAACd,IAAI,CAAC,GAAGc,YAAY,CAACd,IAAI,CAAC;EAC9G;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACE,SAASc,YAAYA,CAACd,IAAI,EAAE;IAC1B,IAAIA,IAAI,KAAK,EAAE,EAAE;MACf,OAAOe,WAAW,CAACf,IAAI,CAAC;IAC1B;IACA,OAAOnD,kBAAkB,CAAC6C,OAAO,EAAEsB,wBAAwB,EAAEC,0BAA0B,EAAE,qBAAqB,EAAE,4BAA4B,EAAE,kCAAkC,EAAE,wBAAwB,EAAE,2BAA2B,EAAE,EAAE,CAAC,CAACjB,IAAI,CAAC;EACpP;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACE,SAASgB,wBAAwBA,CAAChB,IAAI,EAAE;IACtC,OAAO/C,yBAAyB,CAAC+C,IAAI,CAAC,GAAGhD,iBAAiB,CAAC0C,OAAO,EAAEwB,eAAe,CAAC,CAAClB,IAAI,CAAC,GAAGe,WAAW,CAACf,IAAI,CAAC;EAChH;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACE,SAASiB,0BAA0BA,CAACjB,IAAI,EAAE;IACxC,OAAOJ,GAAG,CAACI,IAAI,CAAC;EAClB;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACE,SAASkB,eAAeA,CAAClB,IAAI,EAAE;IAC7B,IAAIA,IAAI,KAAK,EAAE,IAAIA,IAAI,KAAK,EAAE,IAAIA,IAAI,KAAK,EAAE,EAAE;MAC7C,OAAOjD,YAAY,CAAC2C,OAAO,EAAEyB,kBAAkB,EAAEvB,GAAG,EAAE,eAAe,EAAE,qBAAqB,EAAE,qBAAqB,CAAC,CAACI,IAAI,CAAC;IAC5H;IACA,OAAOe,WAAW,CAACf,IAAI,CAAC;EAC1B;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACE,SAASmB,kBAAkBA,CAACnB,IAAI,EAAE;IAChC,OAAO/C,yBAAyB,CAAC+C,IAAI,CAAC,GAAGhD,iBAAiB,CAAC0C,OAAO,EAAEqB,WAAW,CAAC,CAACf,IAAI,CAAC,GAAGe,WAAW,CAACf,IAAI,CAAC;EAC5G;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACE,SAASe,WAAWA,CAACf,IAAI,EAAE;IACzB,IAAIA,IAAI,KAAK,EAAE,EAAE;MACfN,OAAO,CAACW,KAAK,CAAC,gBAAgB,CAAC;MAC/BX,OAAO,CAACY,OAAO,CAACN,IAAI,CAAC;MACrBN,OAAO,CAACa,IAAI,CAAC,gBAAgB,CAAC;MAC9Bb,OAAO,CAACa,IAAI,CAAC,UAAU,CAAC;MACxB,OAAOZ,EAAE;IACX;IACA,OAAOC,GAAG,CAACI,IAAI,CAAC;EAClB;AACF;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAShC,qBAAqBA,CAAC0B,OAAO,EAAEC,EAAE,EAAEC,GAAG,EAAE;EAC/C,MAAMC,IAAI,GAAG,IAAI;EACjB,OAAOuB,aAAa;;EAEpB;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACE,SAASA,aAAaA,CAACpB,IAAI,EAAE;IAC3B,OAAOlD,YAAY,CAACuE,IAAI,CAACxB,IAAI,EAAEH,OAAO,EAAE4B,kBAAkB,EAAEC,oBAAoB,EAAE,WAAW,EAAE,iBAAiB,EAAE,iBAAiB,CAAC,CAACvB,IAAI,CAAC;EAC5I;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACE,SAASsB,kBAAkBA,CAACtB,IAAI,EAAE;IAChC,OAAOH,IAAI,CAACP,MAAM,CAACS,OAAO,CAACG,QAAQ,CAAC9C,mBAAmB,CAACyC,IAAI,CAACM,cAAc,CAACN,IAAI,CAAC1B,MAAM,CAAC0B,IAAI,CAAC1B,MAAM,CAACG,MAAM,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAACe,KAAK,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC,CAAC,GAAGM,EAAE,CAACK,IAAI,CAAC,GAAGJ,GAAG,CAACI,IAAI,CAAC;EAC3J;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACE,SAASuB,oBAAoBA,CAACvB,IAAI,EAAE;IAClC,OAAOJ,GAAG,CAACI,IAAI,CAAC;EAClB;AACF;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS9B,0BAA0BA,CAACwB,OAAO,EAAEC,EAAE,EAAEC,GAAG,EAAE;EACpD,OAAO4B,uBAAuB;;EAE9B;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACE,SAASA,uBAAuBA,CAACxB,IAAI,EAAE;IACrC;;IAEAN,OAAO,CAACW,KAAK,CAAC,WAAW,CAAC;IAC1BX,OAAO,CAACW,KAAK,CAAC,iBAAiB,CAAC;IAChCX,OAAO,CAACY,OAAO,CAACN,IAAI,CAAC;IACrBN,OAAO,CAACa,IAAI,CAAC,iBAAiB,CAAC;IAC/B,OAAOkB,sBAAsB;EAC/B;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACE,SAASA,sBAAsBA,CAACzB,IAAI,EAAE;IACpC,IAAIA,IAAI,KAAK,EAAE,EAAE;MACfN,OAAO,CAACW,KAAK,CAAC,iBAAiB,CAAC;MAChCX,OAAO,CAACY,OAAO,CAACN,IAAI,CAAC;MACrBN,OAAO,CAACa,IAAI,CAAC,iBAAiB,CAAC;MAC/Bb,OAAO,CAACa,IAAI,CAAC,WAAW,CAAC;MACzB,OAAOZ,EAAE;IACX;IACA,OAAOC,GAAG,CAACI,IAAI,CAAC;EAClB;AACF","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}